#pragma config(Sensor, in1,    IRSensor1,      sensorReflection)
#pragma config(Sensor, dgtl2,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, redLED,         sensorDigitalOut)
#pragma config(Motor,  port2,           Right,         tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port10,          Left,          tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum {
	SCAN = 0,
	LIGHT_OFF,
	LIGHT_ON,
	STOP,
} T_State;

const int light_threshold = 17;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight()
{
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRSensor1];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}

task main()
{ //robot will scan for target
	T_State robot_state = SCAN;
	bool beaconVisible;
	SensorValue[redLED] = 0;

	while( true ) {
		// Update sensor values (must be called at least 20 times a second for proper performance).
		beaconVisible = monitorLight();
		switch( robot_state ) {
//robot rotates until it sees beacon
		case SCAN:
			if(beaconVisible){
				robot_state = STOP;
			} else {
			motor[Right] = -35;
			motor[Left] = 35;
			}
			break;
//stops when it sees beacon
			case STOP:
			motor[Left] = 0;
			motor[Right] = 0;
			robot_state = LIGHT_ON;
			break;

			case LIGHT_OFF:
			SensorValue[redLED] = 0;
			if ( beaconVisible ) {
				robot_state = LIGHT_ON;
				} else {
				robot_state = LIGHT_OFF;
			}
			break;

			case LIGHT_ON:
			SensorValue[redLED] = 1;
			robot_state = LIGHT_ON;
			break;

			default:
		// This should never happen.
			robot_state = LIGHT_OFF;

		} // switch( robot_state)

	}  // while(true)

}
